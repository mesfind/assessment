geom_bar(stat = "identity",
position = "dodge") +
geom_text(aes(label = n),
size = 4,
vjust = -0.25,
position = position_dodge(width = 1)) +
ylim(c(0, 60)) +
facet_wrap(~ Status, ncol = 1) +
scale_x_discrete(labels = function(x) lapply(strwrap(x,
width = 10,
simplify = FALSE),
paste,
collapse = "\n")) +
theme_classic() +
xlab("Figure 10: Respondents' Programming Usage Increased (Grouped)") +
ylab("% Respondents (actual counts above bars)") +
scale_fill_discrete(name = "",
labels = c("Before Workshop", "After Workshop")) +
ggtitle("Figure 10: Programming Usage Pre/Post by Status") +
theme(plot.title = element_text(hjust = 0.5)) +
theme_classic(base_size = 14)
ggsave("figures/change_in_programming_usage_by_group.png")
# The code below from Ben provides a chi-square plot of the pre/post residuals
# Let's talk about this plot and whether to include it. If it's not easy to understand we shouldn't
# use it.
pre_and_post_test <-
pre_and_post_usage %>%
select(-perc) %>%
spread(value, n) %>%
ungroup()
# chi-sq test
pre_and_post_test_result <-
chisq.test(pre_and_post_test[ , !names(pre_and_post_test) == 'key'])
# standardised residuals
stdres <- data.frame(t(pre_and_post_test_result$stdres))
names(stdres) <- pre_and_post_test$key
stdres$freq <- row.names(stdres)
# just show post-workshop
stdres <- stdres[, c(2,3)]
names(stdres) <- rev(c("Frequency", "Residual"))
# large positive residuals means there were more xxx than the hypothesis of independence predicts. Where are our large +ve residuals?
# Contribution in percentage (%)
# The contribution (in %) of a given cell to the total Chi-square score is calculated as follows:
contrib <- 100 * pre_and_post_test_result$residuals^2 / pre_and_post_test_result$statistic
# scale 0 to 1 to use as alpha
range0to1 <- function(x){(x-min(x))/(max(x)-min(x))}
# reorder to match order of programming factor
contrib_0_to_1 <- as.vector(range0to1(contrib))[c(3,5,9,7,11,1)]
# colour +ve and -ve values
# http://stackoverflow.com/a/12910865/1036500
stdres$sign = ifelse(stdres$Residual >= 0,
"positive",
"negative")
# get the categories in a sensible order
ggplot(stdres,
aes(factor(Frequency,
levels = programming),
Residual,
fill = sign)) +
geom_col(position = "dodge",
aes(alpha = contrib_0_to_1)) +
xlab("Figure 11: Respondents program significantly more often") +
ylab("Chi-square standardized residuals of\npost-workshop frequencies") +
scale_x_discrete(labels = function(x) lapply(strwrap(x, width = 10, simplify = FALSE), paste, collapse = "\n")) +
scale_fill_manual(name = "",
values = c("negative" = "red",
"positive" = "blue"),
labels = c("Fewer respondents than \nexpected assuming no effect",
"More respondents than \nexpected assuming no effect")) +
ggtitle("") +
theme(plot.title = element_text(hjust = 0.5)) +
theme_classic(base_size = 14) +
scale_alpha_continuous("Contribution to \nchi-square value") +
guides(fill=guide_legend(
keywidth = 0.1,
keyheight = 0.4,
default.unit = "inch")
)
ggsave("figures/programming_post_workshop.png")
# Code for change in confidence
confidence <-
c("I'm less confident now.",
"I'm equally confident now.",
"I'm more confident now.")
confidence = factor(confidence)
round1data$`Change-In-Confidence` = factor(round1data$`Change-In-Confidence`, levels = confidence)
data_change.in.confidence_tally <-
round1data %>%
group_by(`Change-In-Confidence`) %>%
tally() %>%
filter(!is.na(`Change-In-Confidence`)) %>%
mutate(perc = round(n / sum(n) * 100, 0 ))
# Use the code below for a table of the data.
# kable(data_change.in.confidence_tally, format = "markdown", row.names = FALSE, col.names = c("Change in Confidence", "%"))
ggplot(data_change.in.confidence_tally,
aes(`Change-In-Confidence`, y = 100 * (n/sum(n)),
n)) +
geom_bar(stat = "identity", fill = "grey") +
geom_text(aes(label=n), size= 4, vjust=-0.25) +
scale_x_discrete(labels = function(x) lapply(strwrap(x, width = 10, simplify = FALSE), paste, collapse="\n")) +
theme_classic() +
xlab("Change in Confidence") +
ylab("% Respondents") +
ggtitle("Figure 12: Change in Confidence 6 Months Later") +
theme(plot.title = element_text(hjust = 0.5)) +
theme_bw(base_size = 14)
ggsave("figures/change_in_confidence.png")
status <- unique(round1data$Position)
status <- factor(status[!is.na(status)])
# What is your position?
status <- factor(status, levels(status)[c(7, 3, 6, 2, 1, 5, 4)])
# Display ordering.
print(levels(status))
round1data$Position <-
factor(round1data$Position, levels = levels(status))
change_in_confidence_by_status <- round1data %>%
group_by(`Change-In-Confidence`, Position) %>%
tally() %>%
filter(!is.na(`Change-In-Confidence`)) %>%
group_by(Position) %>%
mutate(n_status = sum(n)) %>%
filter(!is.na(Position)) %>%
mutate(perc = n / n_status * 100)
# Check that percentage total is 100 for each status (Position).
test_output <- change_in_confidence_by_status %>%
group_by(Position) %>%
summarize(total = sum(perc))
expect_equal(test_output$total, rep(100, length(status)))
ggplot(data = change_in_confidence_by_status,
aes(x = `Change-In-Confidence`, y = Position)) +
geom_tile(aes(fill = perc), colour = "white") +
geom_text(aes(label = paste0(round(perc, 1), "%"))) +
scale_fill_gradient("Percent",
low = "white",
high = "blue",
limits = c(0, 100)) +
xlab("Change in Confidence") +
theme(
axis.text.x = element_text(angle = 30, hjust = 1),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.ticks = element_blank(),
panel.background = element_blank()
)
ggsave("figures/change_in_confidence_by_status.png")
# Focus on Engineering
change_in_conf_eng <- round1data %>%
filter(grepl("Engineering", Column6)) %>%
group_by(`Change-In-Confidence`) %>%
tally() %>%
filter(!is.na(`Change-In-Confidence`)) %>%
mutate(perc = n / sum(n) * 100)
ggplot(change_in_conf_eng,
aes(`Change-In-Confidence`, y = perc, n)) +
geom_bar(stat = "identity", fill = "grey") +
geom_text(aes(label=n), size= 4, vjust=-0.25) +
scale_x_discrete(labels = function(x) lapply(strwrap(x, width = 10,
simplify = FALSE), paste,
collapse="\n")) +
theme_classic() +
xlab("Change in Confidence (Engineering)") +
ylab("% Respondents") +
ggtitle("") +
theme(plot.title = element_text(hjust = 0.5)) +
theme_bw(base_size = 14)
ggsave("figures/change_in_confidence_eng.png")
# Breakdown by status.
change_in_conf_eng_by_status <- round1data %>%
filter(grepl("Engineering", Column6)) %>%
group_by(`Change-In-Confidence`, Position) %>%
tally() %>%
filter(!is.na(`Change-In-Confidence`)) %>%
group_by(Position) %>%
mutate(n_status = sum(n)) %>%
filter(!is.na(Position)) %>%
mutate(perc = n / n_status * 100)
# Check that percentage total is 100 for each status (Position).
test_output <- change_in_conf_eng_by_status %>%
group_by(Position) %>%
summarize(total = sum(perc))
expect_equal(test_output$total, rep(100, length(status)))
ggplot(data = change_in_conf_eng_by_status,
aes(x = `Change-In-Confidence`, y = Position)) +
geom_tile(aes(fill = perc), colour = "white") +
geom_text(aes(label = n)) +
scale_fill_gradient("Percent",
low = "white",
high = "blue",
limits = c(0, 100)) +
xlab("Change in Confidence (Engineering)") +
theme(
axis.text.x = element_text(angle = 30, hjust = 1),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.ticks = element_blank(),
panel.background = element_blank()
)
ggsave("figures/change_in_conf_eng_by_status.png")
# Data are in columns 'How-Tools-Learned-Help' through 'Column37'
# how many responses do we have to this question?
n_reponses_tools_learned_help <-
n_responses_to_the_question(round2data,
from_colname = `HowToolsHelped`,
to_colname = Column37)
# How many responded to either of these?
# They are improving my overall efficienct : How.Tools.Learned.Helped
# They are improving my ability to analyze data. : Column34
# They are improving my ability to manage data. : Column35
relevant_cols <- c("HowToolsHelped", "Column34", "Column35")
rowsums <-
round2data %>%
select(one_of(relevant_cols)) %>%
# check that each row has a value for at least one col
# convert to numeric, if NA, then put a zero, otherwise 1
map_df(., ~ifelse(is.na(.x), 0, 1)) %>%
# sum to see if any rows have no reponses
rowSums()
idx <- ifelse(rowsums == 0, FALSE, TRUE)
number_that_tools_helped <- sum(idx)
how_help <-
round2data %>%
select(`HowToolsHelped`:Column37) %>%
gather(col, how_help) %>%
group_by(how_help) %>%
tally() %>%
filter(!is.na(how_help)) %>%
arrange(desc(n)) %>%
rename(`HowToolsHelped` = how_help)
tools_helped <-
round2data %>%
select(`HowToolsHelped`:Column37) %>%
gather(col, tools_helped) %>%
group_by(tools_helped) %>%
tally_and_perc(tools_helped, na.rm = TRUE, question_n = n_reponses_tools_learned_help) %>%
filter(!is.na(tools_helped)) %>%
arrange(desc(n)) %>%
rename(`How Tools Covered Have Helped` = tools_helped)
kable(tools_helped,
format = "markdown",
row.names = FALSE,
caption = "Self-Reported Perception of How Tools Help Respondents")
# Code chunk for contributions to academic writing
# how many responded to this question?
rowsums <-
round2data %>%
select(`Writing`) %>%
# check that each row has a value for at least one col
# convert to numeric, if NA, then put a zero, otherwise 1
map_df(., ~ifelse(is.na(.x), 0, 1)) %>%
# sum to see if any rows have no reponses
rowSums()
# for all writing responses
idx <- ifelse(rowsums == 0, FALSE, TRUE)
n_responsed_to_writing <-  sum(idx)
# table about writing
round2data %>%
tally_and_perc(`Writing`,
na.rm = TRUE,
question_n = n_responsed_to_writing) %>%
kable()
writing = c("No.", "Not sure.", "Yes.")
writing = factor(writing)
round2data$`Writing` = factor(round2data$`Writing`, levels = writing)
Contributed_Writing <- round(prop.table(table(round2data$`Writing`)) * 100)
# Jonah's fix to include the correct levels. Variable was renamed to 'levels'
# because 'order' is the name of a function in R.
# I am still not sure if this plot is 100% correct -KLJ
cols_with_Agree <- map_lgl(round2data, ~`%in%`("Agree", .x))
data_agree <-  round2data[ , cols_with_Agree]
levels = c("Strongly disagree", "Disagree", "Neutral", "Agree", "Strongly agree")
# Beth's tip to both order the factors based on levels and unify the factors
factorfunction <- function(mydata, factlevel){
factor(mydata,
levels=factlevel,
ordered = TRUE)
fct_unify(mydata,
levels=factlevel)}
# End tip
# Adjusting names of y axis labels
names(data_agree) <-
c("Coding",
"Confidence",
"Career",
"Motivation",
"Reproducible",
"Productivity",
"Recognition")
data_agree_likert <- likert(data.frame(lapply(data_agree, factor, levels, ordered=TRUE)))
agree_or_strongly_agree_improved_3_things <-
data_agree %>%
select(Coding, Reproducible, Productivity) %>%
filter(Coding       %in% c("Agree", "Strongly agree") | # or
Reproducible %in% c("Agree", "Strongly agree") |
Productivity %in% c("Agree", "Strongly agree"))
perc_agree_or_strongly_agree_improved_3_things <-
round(nrow(agree_or_strongly_agree_improved_3_things) / nrow(data_agree) * 100, 0)
received_professional_recognition <-
data_agree_likert$results %>%
filter(Item == "Recognition") %>%
select(Agree, `Strongly agree`) %>%
sum() %>%
round(0)
title <- "Figure: Perception of Workshop Impact"
plot(data_agree_likert, type =c("heat"), panel.arrange = NULL, panel.strip.color = "red", legend.position = "bottom") + ggtitle(title)
ggsave("figures/workshop_impact_heatmap.png")
# How can we change the axis labels to make them easier to understand?
# Plot includes Ben's tip to add a percent column to the data_country_tally data frame
# before it goes into the ggplot() function to use reorder on that column name in the ggplot() function
# This plot uses round1data because we asked what Country they attended a workshop in that version of the
# survey
round1data_country_tally <-
round1data %>%
group_by(Country) %>%
tally(sort = TRUE) %>%
mutate(perc = round(100 * (n/sum(n)), 1)) %>% # add the % col
filter(!is.na(Country)) %>%
arrange(desc(n))
ggplot(round1data_country_tally,
aes(reorder(Country, perc),
perc)) +
geom_bar(stat = "identity", fill = "grey") +
theme_classic() +
xlab("") +
ylab("Figure X: Breakdown of Respondents by Country") +
coord_flip() +
ggtitle("") +
theme(plot.title = element_text(hjust = 0.5)) +
theme_bw(base_size = 14)
ggsave("figures/percent_by_country.png")
# What is your gender?
# Gender was added to the survey during the second round of data collection. That is why I used round2data
# in the code below. Only six people responded with their gender, so we aren't including this information.
gender = c("Female", "Male", "I prefer not to say")
gender = factor(gender)
round2data$Gender = factor(round2data$Gender, levels = gender)
round2data_gender_tally <-
round2data %>%
group_by(Gender) %>%
tally() %>%
filter(!is.na(Gender)) %>%
mutate(perc = round(n/sum(n) * 100, 0))
kable(round2data_gender_tally)
# How would you describe yourself?
# Responses are in columns 'Race' through 'Column50'
# Using 'gather' to go from wide to long format
n_responses_race <-
n_responses_to_the_question(round2data,
from_colname = Race,
to_colname = Column50)
race_perc <-
round2data %>%
select(Race:Column50) %>%
gather(col, race_perc) %>%
group_by(race_perc) %>%
tally_and_perc(race_perc,
na.rm = TRUE,
question_n = n_responses_race) %>%
filter(!is.na(race_perc)) %>%
arrange(desc(n)) %>%
rename(Race = race_perc)
kable(race_perc)
# Only 8 persons responded to this question, so we will not include this in the report.
# Table of number of workshops that participants have attended
round2data %>%
filter(!is.na(NumWorkshops)) %>%
select(NumWorkshops) %>%
group_by(NumWorkshops) %>%
tally() %>%
kable(col.names = c("Number of Workshops Attended",
"n"),
caption = "Number of workshops attended (Post-survey)")
# Table of time since workshop attendance
round2data %>%
filter(!is.na(TimeSinceWorkshop)) %>%
select(TimeSinceWorkshop) %>%
group_by(TimeSinceWorkshop) %>%
tally() %>%
kable(col.names = c("Time Since Last Attending Workshop",
"n"),
caption = "Time since workshop attendence (Post-survey)")
table_of_status_by_field <- round2data %>%
select(Status, Field:FieldOther) %>%
gather(key = "Field",
value = "value",
-Status,
na.rm = TRUE) %>%
select(-Field) %>%
table() %>%
t()
top_12_fields <- table_of_status_by_field  %>%
as_tibble() %>%
group_by(value) %>%
summarize(sum_by_field = sum(n)) %>%
arrange(desc(sum_by_field)) %>%
head(12) %>%
pull(value)
# table of participant counts in each category (multiple selection was possible)
table_of_status_by_field %>%
as_tibble() %>%
filter(value %in% top_12_fields) %>%
spread(Status, n) %>%
kable()
# plot of the same
table_of_status_by_field %>%
as_tibble() %>%
filter(value %in% top_12_fields) %>%
ggplot(aes(x = Status,
y = value,
fill = n)) +
geom_tile() +
geom_text(aes(label = round(n, 0))) +
scale_fill_gradient("n",
low = "white",
high = "blue") +
labs(title = "Number of Respondants by Field (top 12 most common) and Career Stage",
subtitle = "Note: Multiple selections possible per person",
y = "Field",
x = "Career Stage/Status") +
theme(axis.text.x = element_text(angle = 45,
hjust = 1),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.ticks = element_blank(),
panel.background = element_blank())
# Code for involvement (rows Involvement through Column57)
# I want to use the tally_and_perc function, but don't know where to put the question_n
Carpentry_Involvement <-
round2data %>%
select(`Involvement`:Column57) %>%
gather(col, Carpentry_Involvement) %>%
group_by(Carpentry_Involvement) %>%
tally() %>%
filter(!is.na(Carpentry_Involvement)) %>%
arrange(desc(n)) %>%
rename(`Involvement Since Attending a Carpentry Workshop` = Carpentry_Involvement)
kable(Carpentry_Involvement)
# Code for matrix of involvement (thanks Ben for the tip!)
# Combinations of tools for individual
involvement_cols <-
round2data %>%
select(`Involvement`:Column57)
# Matrix tool-by-tool
m <- as.matrix(involvement_cols)
# the unique values in the matrix
vals <- sort(unique(as.vector(m)))
# rearrange the data so that each value is a column
bigm <- t(apply(m, 1, function(row) match(vals, row, nomatch=0)))
colnames(bigm) <- vals
# count the co-occurences of each value (diagonal is total number of rows with that value)
involvement_co_occurences  <- as.data.frame(crossprod(bigm>0))
kable(involvement_co_occurences,
row.names = TRUE,
caption = "Matrix of Common Involvement")
# Code chunk for continuous learning
Learning_Activities <-
round2data %>%
select(`ContinuousLearning`:Column63) %>%
gather(col, Learning_Activities) %>%
group_by(Learning_Activities) %>%
tally() %>%
filter(!is.na(Learning_Activities)) %>%
mutate(`%` =round(n / sum(n) * 100, 0) ) %>%
arrange(desc(n)) %>%
rename(`Continuous Learning Post-Workshop` = Learning_Activities)
# Code chunk for table of continuous learning activities
kable(Learning_Activities,
format = "markdown",
row.names = FALSE,
col.names = c("Continuous Learning", "n", "%"),
caption = "Respondents Self-Reported Continuous Learning Activities")
# Code for matrix of continuous learning (thanks Ben for the tip!)
# Combinations of involvement for individual
learning_cols <-
round2data %>%
select(`ContinuousLearning`:Column63)
# Matrix
m <- as.matrix(learning_cols)
# the unique values in the matrix
vals <- sort(unique(as.vector(m)))
# rearrange the data so that each value is a column
bigm <- t(apply(m, 1, function(row) match(vals, row, nomatch=0)))
colnames(bigm) <- vals
# count the co-occurences of each value (diagonal is total number of rows with that value)
learning_co_occurences  <- as.data.frame(crossprod(bigm>0))
kable(learning_co_occurences, row.names = TRUE, caption = "Matrix of Common Post-Workshop Learning Activities")
# Code chunk for whether respondents recommended a workshop
recommended <-
round2data %>%
select(Recommended) %>%
gather(col, Recommended) %>%
group_by(Recommended) %>%
tally() %>%
filter(!is.na(Recommended)) %>%
mutate(`%` =round(n / sum(n) * 100, 0) ) %>%
arrange(desc(n)) %>%
rename(`Recommended a Workshop?` = Recommended)
# Table for responses of recommendations
kable(recommended)
# If interested in seeing the open-ended responses for Position: Other, run this code.
round2data_field_other_tally <-
round2data %>%
group_by(`FieldOther`) %>%
tally() %>%
filter(!is.na(`FieldOther`))
kable(round2data_field_other_tally, format = "markdown", row.names = FALSE, col.names = c("Field-Other", "# Respondents"))
# If interested in seeing the open-ended responses for Status: Other, run this code.
round2data_status_other_tally <-
round2data %>%
group_by(`StatusOther`) %>%
tally() %>%
filter(!is.na(`StatusOther`))
kable(round2data_status_other_tally, format = "markdown", row.names = FALSE, col.names = c("Status-Other", "# Respondents"))
