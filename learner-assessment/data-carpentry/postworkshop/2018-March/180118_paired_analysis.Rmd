## [DRAFT] Data Carpentry's Paired Pre and Post-Workshop Survey Report 
March 2018

```{r setup, include=FALSE}
library(knitr)
library(tidyverse)
library(DBI)
library(ggmap)
library(likert)
library(mapproj)
library(RColorBrewer)
library(srvyr)
library(beeswarm)
library(NPS)
opts_chunk$set(echo = FALSE,
               message = FALSE,
               warning = FALSE)
opts_chunk$set(fig.path='/figures') #puts all figures in figures folder
```

```{r}
# Pre-Workshop Data
predata <- readr::read_csv("https://raw.githubusercontent.com/carpentries/assessment/master/learner-assessment/data-carpentry/postworkshop/2018-March/180118_dcpre.csv")

# Post-Workshop Data
postdata <- readr::read_csv("https://raw.githubusercontent.com/carpentries/assessment/master/learner-assessment/data-carpentry/postworkshop/2018-March/180108_dcpost.csv")
```

```{r}
# Function that makes a table of counts and percentages
tally_and_perc <- function(df, colname, na.rm = FALSE){
  quo_colname <- enquo(colname)

  df %>% 
    group_by(!!quo_colname) %>% 
    tally() %>% 
    filter(if_else(rep(na.rm, nrow(.)),
                  !is.na(!!quo_colname),
                  as.logical(rep(1, nrow(.))))) %>% 
    mutate(`%` = round(n / sum(n) * 100, 1)) 
}
```

# Pre-Workshop Survey Demographics

## Workshop Location

```{r}
data_country_tally <-
  predata %>% 
  tally_and_perc(`Country`, na.rm = TRUE) %>%
  arrange(desc(n))

kable(data_country_tally, format='markdown')
```

## Respondents Discipline

```{r}
# Responses are in columns 'Discipline' through 'Column13'
discipline <-
 predata %>%
 select(`Discipline`:Column13) %>%
 gather(col, discipline) %>%
 group_by(discipline) %>%
 tally_and_perc(discipline) %>%
 filter(!is.na(discipline)) %>%
 arrange(desc(n)) %>%
 rename(`Discipline` = discipline)

kable(discipline, format = 'markdown', row.names = NA, col.names = c ("Respondents Discipline", "n", "%"))
# The percentages in the table are incorrect
```

## Respondents Status

```{r}
# Responses are in columns 'Discipline' through 'Column22'
ordered_status = c("Undergraduate Student", "Graduate Student", "Postdoctoral Researcher", "Faculty", "Industry Employee", "Government Employee", "Research Staff", "Management/Administrator", "Retired/Not Employed", "Other (please specify)")

predata$Status = factor(predata$Status, levels = ordered_status)

status <-
 predata %>%
 select(`Status`:Column22) %>%
 gather(col, status) %>%
 group_by(status) %>%
 tally_and_perc(status) %>%
 filter(!is.na(status)) %>%
 arrange(desc(n)) %>%
 rename(`Status` = status)

kable(status, caption = "Status")
# The percentages in the table are incorrect
```

## Pre/Post Comparison

Learners were asked to rate their level of agreement with the following statements related to Data Carpentry's workshop goals and learning objectives. The figure below provides a visual representation of their responses, comparing them before the workshop and after the workshop. Axis labels and the corresponding question are as follows:  

+ __WriteProgram__: I can write a small program/script/macro to solve a problem in my own work.  
+ __TechnicalQuestions__: I know how to search for answers to my technical questions online.  
+ __RawData__: Having access to the original, raw data is important to be able to repeat an analysis.    
+ __ProgrammingEasier__: Using a programming language (like R or Python) can make my analyses easier to reproduce.   
+ __OvercomeProblem__: While working on a programming project, if I get stuck, I can find ways of overcoming the problem.   
+ __ImmediatelyApply__: I can immediately apply what I learned at this workshop. 
+ __ConfidentProgramming__: I am confident in my ability to make use of programming software to work with data.   
+ __ConfidenceSoftware__: Using a programming language (like R or Python) can make me more efficient at working with data.  
+ __ComfortableLearning__: I felt comfortable learning in this workshop environment.
```{r}
# Ability to perform various computing tasks before and after completing the workshop
impact_pre <-
    c("Strongly disagree",
    "Disagree",
    "Neutral",
    "Agree",
    "Strongly agree")

impact_post <- 
  c("Strongly disagree",
    "Disagree",
    "Neutral",
    "Agree",
    "Strongly agree")
# How do I tell R that I want the factors in this order always?
```

# Pre-Workshop
```{r}
# Compute for all tools.

# Before the workshop
pre_computing <- 
predata %>%
  select(`RawData`:`AnalysesEasier`) %>% 
  gather() %>% 
  filter(value %in% impact_pre) %>% 
  nest(-key) %>% 
  mutate(tallies = purrr::map(data, ~tally_and_perc(.x, value))) %>% 
  unnest(tallies)
kable(pre_computing, format = 'markdown', row.names = NA, col.names = c ("Statement", "Level of Agreement", "n", "%"))
```

# Post-Workshop
```{r}
# After the workshop
post_computing <- 
postdata %>%
  select(`RawData`:`AnalysesEasier`) %>% 
  gather() %>% 
  filter(value %in% impact_post) %>% 
  nest(-key) %>% 
  mutate(tallies = purrr::map(data, ~tally_and_perc(.x, value)))  %>% 
  unnest(tallies) 
kable(post_computing, format = 'markdown', row.names = NA, col.names = c ("Statement", "Level of Agreement", "n", "%"))
```

```{r}
# Plot before a grouped bar plot, then combine.

computing_before <- 
   ggplot(pre_computing, 
         aes(x = key,
             y = `%`,
             fill = fct_relevel(value, 
                             impact_pre))) +
    geom_col(position = "dodge") +
    geom_text(aes(label=n), 
              size= 4, vjust=-0.25,
              position=position_dodge(width=1)) +
    scale_x_discrete(labels = function(x) lapply(strwrap(x,
                                                         width = 10,
                                                         simplify = FALSE),
                                                 paste,
                                                 collapse = "\n")) +
    theme_classic() +
    xlab("") +
    ylab("% Respondents") +
    ggtitle("Respondent Ability Pre-Workshop") +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme_classic(base_size = 14) +
    theme(legend.position = "bottom", 
          legend.title=element_blank()) 
```

```{r}
# Plot after a grouped bar plot, then combine.
computing_after <- 
   ggplot(post_computing, 
         aes(x = key,
             y = `%`,
             fill = fct_rev(fct_relevel(value, 
                             (impact_post))))) +
    geom_col(position = "dodge") +
    geom_text(aes(label=n), 
              size= 4, vjust=-0.25,
              position=position_dodge(width=1)) +
    scale_x_discrete(labels = function(x) lapply(strwrap(x,
                                                         width = 10,
                                                         simplify = FALSE),
                                                 paste,
                                                 collapse = "\n")) +
    theme_classic() +
    xlab("") +
    ylab("% Respondents") +
    ggtitle("Level of Confidence Post-Workshop") +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme_classic(base_size = 14) +
    theme(legend.position = "bottom", 
          legend.title=element_blank())  
# + guides(fill = guide_legend(nrow = 2)) # wraps legend
```          

```{r change_in_confidence} 
# Put the two plots together
library(gridExtra)
grid.arrange(computing_before, 
             computing_after,
             ncol = 1)

# Why are the levels showing in a different order on the grid?
```

# Recommending Data Carpentry Workshops
Learners were asked how likely they are to recommend this workshop to a friend or colleague using the [Net Promoter Score](https://en.wikipedia.org/wiki/Net_Promoter). The scoring for this question based on a 0 to 100 scale. Respondents scoring from 0 to 64 are labeled *Detractors*, and are believed to be less likely to recommend a workshop. Those who respond with a score of 85 to 100 are called *Promoters*, and are considered likely to recommend a workshop. Respondents between 65 and 84 are labeled *Passives*, and their behavior falls in the middle of Promoters and Detractors. 

```{r}
postdata$`LikelyToRecommend` %>%
    npc(breaks = list(0:64, 65:84, 85:100)) %>%
    data.frame(category = .) %>%
    filter(!is.na(category)) %>%
    count(category) %>%
    mutate("%" = (n / sum(n))*100) %>%
    kable(, format = 'markdown', row.names = NA, col.names = c ("Promoter Score", "n", "%"))
```


```{r agreement_pre}
   ggplot(pre_computing, 
         aes(x = key,
             y = `%`,
             fill = fct_relevel(value, 
                             impact_pre))) +
    geom_col(position = "dodge") +
    geom_text(aes(label=n), 
              size= 4, vjust=-0.25,
              position=position_dodge(width=1)) +
    scale_x_discrete(labels = function(x) lapply(strwrap(x,
                                                         width = 10,
                                                         simplify = FALSE),
                                                 paste,
                                                 collapse = "\n")) +
    theme_classic() +
    xlab("") +
    ylab("% Respondents") +
    ggtitle("Level of Agreement Pre-Workshop") +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme_classic(base_size = 14) +
    theme(legend.position = "bottom", 
          legend.title=element_blank())
```

```{r agreement_post}
ggplot(post_computing, 
         aes(x = key,
             y = `%`,
             fill = fct_rev(fct_relevel(value, 
                             (impact_post))))) +
    geom_col(position = "dodge") +
    geom_text(aes(label=n), 
              size= 4, vjust=-0.25,
              position=position_dodge(width=1)) +
    scale_x_discrete(labels = function(x) lapply(strwrap(x,
                                                         width = 10,
                                                         simplify = FALSE),
                                                 paste,
                                                 collapse = "\n")) +
    theme_classic() +
    xlab("") +
    ylab("% Respondents") +
    ggtitle("Level of Agreement Post-Workshop") +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme_classic(base_size = 14) +
    theme(legend.position = "bottom", 
          legend.title=element_blank())  
```
## Pre-Workshop

__WriteProgram__: I can write a small program/script/macro to solve a problem in my own work.
```{r}
# I can write a small program/script/macro to solve a problem in my own work.
levels_write_pre <-
    c("Strongly disagree",
    "Disagree",
    "Neutral",
    "Agree",
    "Strongly agree")
levels_write_pre = factor(levels_write_pre)

predata$WriteScript = factor(predata$WriteScript, levels = levels_write_pre)

data_write_pre_tally <- 
  predata %>% 
  group_by(WriteScript) %>% 
  tally() %>%
  filter(!is.na(WriteScript)) 
```

```{r write_program_pre}
ggplot(data_write_pre_tally, 
       aes(`WriteScript`, y = 100 * (n/sum(n)),
           n)) +
  geom_bar(stat = "identity", fill="purple") +
  geom_text(aes(label=n), size= 4, vjust=-0.25) +
  scale_x_discrete(labels = function(x) lapply(strwrap(x, width = 10, simplify = FALSE), paste, collapse="\n")) +
  theme_classic() +
  xlab("Self-Reported Pre-Workshop Scores") +
  ylab("% Respondents") +
  ggtitle("I can write a small program/script/macro to solve a problem \nin my own work.") +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme_classic(base_size = 14)
```

```{r}
# This is the code to join both dataframes by UniqueId so that we can run paired analyses
predata$uniqueID = predata[["UniqueID"]]
predata[["UniqueID"]] = NULL

# Which in the table of unique IDs appeared only once?
# Which gave us the position of the vector. We needed to pull out the names, not positions
# Which of the unique IDs are in this list. Only give us the rows in predata which match this condition
# and give us all the columns. We assigned it to a new data frame.
list_unique_ids_pre = names(which(table(predata$uniqueID) == 1))
predata_unique = predata[which(predata$uniqueID %in% list_unique_ids_pre),]

# Do the same for the post data
postdata$uniqueID = postdata[["UniqueID"]]
postdata[["UniqueID"]] = NULL

list_unique_ids_post = names(which(table(postdata$uniqueID) == 1))
postdata_unique = postdata[which(postdata$uniqueID %in% list_unique_ids_post),]

# Now we are ready to combine. Pre responses are labeled with an 'x' and post with a 'y'.
# This is Erin's technique
# combined_data <- merge(predata_unique, postdata_unique, by = c("uniqueID"))

# This is from DataCamp
# Join both data frames
data_merged <- predata_unique %>%
  inner_join(postdata_unique, by = c("uniqueID"))
```

__RawData__ 
Having access to the original, raw data is important to be able to repeat an analysis.


```{r}
# Convert from factor to numeric
RawData.x <- as.numeric(as.character(data_merged$RawData.x))
RawData.y <- as.numeric(as.character(data_merged$RawData.y))
```

```{r}
# Paired t-test
t.test(RawData.x,RawData.y, paired = TRUE)
```
